<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[初识Flutter]]></title>
      <url>https://tomsbee8.github.io/2018/05/13/%E5%88%9D%E8%AF%86Flutter/</url>
      <content type="html"><![CDATA[<h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a><strong>碎碎念</strong></h3><p>在年初的时候，先是看到google 重启dar2项目的消息，当时没有在意，然后不久在google 2018 IO大会上发布了beta3 版本后，才知道Flutter突然都这么火了。陆续在掘金上看到Flutter的文章。也陆续有开源中国版的Flutter版本和boss直聘的Flutter版本，才发现已经落伍了。然后在接下来的日子里，就像是发现了新大陆，沉迷Flutter日渐消瘦。搭建好安卓和iOS环境，然后开始翻阅文档，模仿着写写简单的例子。给我的感觉就是，虽然有好多基本库其实还不是那么强大，比方说json解析，HTTP请求等等，控件虽然不及Android/iOS控件丰富，但是每个widget控件都很精致，而且我觉得可以一套代码可以实现真正意义上的跨平台（对比RN和Weex）开发，真的是让人耳目一新，一颗赛艇。</p>
<p>作为一名原生开发者，最近几年受到来自前端技术威胁的影响, 面对来势汹汹的即将一统江湖的js,我们常常调侃着饭碗都被前段抢了，因此会时常关注各种新技术, 也去由于项目原因，也了解熟悉Weex ,Vue等前端框架。</p>
<h3 id="Flutter是什么"><a href="#Flutter是什么" class="headerlink" title="Flutter是什么"></a><strong>Flutter是什么</strong></h3><p>Flutter一种的新方式，Flutter 是一个允许我们去快速的，美观的去构建<strong>混合移动应用程序</strong>的<strong>移动端 SDK</strong> ，说白了，就是这样你就可以写一份代码，然后同时跑在 Android 和 iOS 上，构建高质量的原生用户界面。</p>
<p>之所以说其真正的跨平台Flutter使用编译的编程语言即Dart的方法来避免JavaScript桥引起的性能问题,。 Dart被“提前编译”（AOT）编译成多个平台的本地代码。 这使得Flutter可以与平台进行通信，而无需通过执行了上下文切换的JavaScript Bridge。 编译为本机代码也可以提高应用程序的启动时间。</p>
<h3 id="Flutter-对比React-Native-Weex"><a href="#Flutter-对比React-Native-Weex" class="headerlink" title="Flutter 对比React Native/Weex"></a><strong>Flutter 对比React Native/Weex</strong></h3><p>这两个平台在用户界面的构建方式差异上很大：</p>
<ul>
<li><p>React Native 和Weex最终是以原生的 iOS 或 Android 组件来渲染界面。在某些情况下，我们可以使用 <code>Native Module</code> 的方式来自定义组件，在 JS 端通过 <code>NativeModules</code> 来引用 Native 组件。</p>
</li>
<li><p>Flutter 是有自己专属的一套 <code>Widget</code>，并通过自身的高性能 C/C++ 渲染引擎来绘制界面。</p>
</li>
</ul>
<h4 id="Flutter-的优势"><a href="#Flutter-的优势" class="headerlink" title="Flutter 的优势"></a><strong>Flutter 的优势</strong></h4><ol>
<li><p>跨平台开发: 可以以独立于操作系统的方式轻松访问平台服务和硬件，如相机或摄像头等。</p>
</li>
<li><p>HotReLoad: 热加载功能，使得调试的体验相当好当程序代码更改时，可以自动执行 <code>Hot Reload</code> 操作，有点像Android的Instant功能。</p>
</li>
<li><p>丰富的UI 库（Material 及 Cupertino）。甚至可以设置不同平台的不同主题。</p>
</li>
</ol>
<h4 id="我的感受"><a href="#我的感受" class="headerlink" title="我的感受"></a>我的感受</h4><ol>
<li>文档挺完善，搭建好环境很容易，一个flutter doctor命令，用起来很顺，基本没遇到社么问题。</li>
<li>dart学起来确实很容易上手，代码看起来还好，代码可读性在接受范围内，没有像网友叫嚣的那么差</li>
<li>pub里的plugin 和package 比较少，很多原生中很容易实现（通过已经成熟的库）的功能，实现起来真费劲，比方说JSON解析。</li>
<li>asset文件配置太过于自由，如果图片太多，管理起来很费劲(或许是我自己没找到其余的好的管理方法？).</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://flutterchina.club/docs/" target="_blank" rel="external">Flutter中文文档</a></li>
<li><a href="https://juejin.im/post/5a38e3f651882527a13d9eb2#heading-14" target="_blank" rel="external">什么是Flutter的革命</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[记录一次IM迁移流程]]></title>
      <url>https://tomsbee8.github.io/2018/03/03/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%AC%AC%E4%B8%89%E6%96%B9IM%E8%BF%81%E7%A7%BB%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近公司出于某些考虑打算更换第三方 IM 服务，我们 app 集成的是环信IM,打算更换为云星的SDK，而且 app 的现有用户量很大。刚好我一直在维护更新 IM 这个模块，然后前段时间 有小伙伴研究了我们 app 的 IM 服务架构迁移技术上的可行性，认为可行。现在呢，正准备实施转移了，虽然讨论了很多方案，我感觉工作量还是相当的大，复杂度还是比较高的。我们端上来协调工作，诸如：制定迁移流程，制定迁移消息协议等。我参与讨论很久，我对于IM的了解还算相对多一些。个人梳理的基本流程是：IM server 里拆解再组装用户和群组数据、App 端上复制本地消息数据、端上强制升级。<br>    <a id="more"></a> </p>
</blockquote>
<h3 id="版本流程"><a href="#版本流程" class="headerlink" title="版本流程"></a>版本流程</h3><table>
<thead>
<tr>
<th>V4.5【最初版本】</th>
<th>V4.6【过渡版本】</th>
<th>V4.7【最终版本】</th>
</tr>
</thead>
<tbody>
<tr>
<td>环信「使用」<br></td>
<td>环信[不使用] <br> 网易云信[使用]</td>
<td><br>网易云信[使用]</td>
</tr>
</tbody>
</table>
<h3 id="升级说明："><a href="#升级说明：" class="headerlink" title="升级说明："></a>升级说明：</h3><ul>
<li><strong>V4.5 —&gt;  V4.6</strong>:为强制升级【也就是说，当4.6版本发布后，视为所有用户为4.6版本】<br>升级后，所有会话使用网易云信通道进行聊天，环信存在的意义在于提供数据复制转移。<br><strong>对于新用户</strong>：注册的时候，只会在网易云信上添加新用户。<br><strong>对于老用户</strong>：用户信息需在升级之前在网易云服务端建立。环信登录后，会进行app端上的本地<strong>数据复制转移</strong>，<br><strong>对于已经存在的群组</strong>：群组需在升级之前在网易云服务端建立。<br><strong>对于新建的群组</strong>：新建群组的时候，只会在网易云信上添加新的群组.</li>
<li><strong>V4.6 —&gt;  V4.7</strong>:不强制升级，升级后只是去除了环信的冗余包和数据</li>
</ul>
<h3 id="数据拆解再组装-："><a href="#数据拆解再组装-：" class="headerlink" title="数据拆解再组装 ："></a>数据拆解再组装 ：</h3><ol>
<li><strong>网易云信Server</strong>: 需要复制用户信息，复制群组信息，实现方式是：在appServer调用环信服务API获取用户信息及群组信息，然后拆解后组装，最后通过调用网易云信服务端API批量创建。</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>备注</th>
<th>API操作文档链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>环信批量获取用户信息</td>
<td>需要多次请求多页数据才能全部完成操作</td>
<td><a href="http://docs.easemob.com/im/100serverintegration/20users" target="_blank" rel="external">获取IM用户【批量】</a></td>
</tr>
<tr>
<td>环信批量获取群组信息</td>
<td>需要多次请求多页数据才能全部操作完成</td>
<td><a href="http://docs.easemob.com/im/100serverintegration/60groupmgmt" target="_blank" rel="external">分页获取app下的群组</a></td>
</tr>
<tr>
<td>网易云信添加用户</td>
<td>不支持批量添加，一次API调用只添加一个</td>
<td><a href="http://dev.netease.im/docs/product/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/%E6%9C%8D%E5%8A%A1%E7%AB%AFAPI%E6%96%87%E6%A1%A3/%E7%BD%91%E6%98%93%E4%BA%91%E9%80%9A%E4%BF%A1ID?#%E5%88%9B%E5%BB%BA%E7%BD%91%E6%98%93%E4%BA%91%E9%80%9A%E4%BF%A1ID" target="_blank" rel="external">创建网易云通信ID</a></td>
</tr>
<tr>
<td>网易云信添加群组</td>
<td>不支持批量添加，一次API调用只添加一个</td>
<td><a href="http://dev.netease.im/docs/product/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/%E6%9C%8D%E5%8A%A1%E7%AB%AFAPI%E6%96%87%E6%A1%A3/%E7%BE%A4%E7%BB%84%E5%8A%9F%E8%83%BD%EF%BC%88%E9%AB%98%E7%BA%A7%E7%BE%A4%EF%BC%89?#%E5%88%9B%E5%BB%BA%E7%BE%A4" target="_blank" rel="external">创建群</a></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>APP端</strong>: 复制本地会话消息,会话的本质还是消息，有了历史消息数据，云信SDK就可以提供会话。所以在端上只需要提供消息的拆解和组装即可。<br>| 操作 | 备注 | 操作文档连接 |<br>| — | — | — |<br>| 环信Android本地消息获取 | 先获取会话列表，然后根据获取会话的历史记录 | [获取聊天记录] (<a href="http://docs.easemob.com/im/200androidclientintegration/50singlechat" target="_blank" rel="external">http://docs.easemob.com/im/200androidclientintegration/50singlechat</a>) |<br>环信iOS本地消息获取 | 先获取会话列表，然后根据获取会话的历史记录 | <a href="http://docs.easemob.com/im/300iosclientintegration/40emmsg" target="_blank" rel="external">消息-&gt;消息检索</a><br>网易云信Android 本地消息插入 | 保存消息到本地数据库，但不发送到服务器端 | <a href="http://dev.netease.im/docs/product/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/SDK%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90/Android%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95?#%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF" target="_blank" rel="external">历史记录–&gt;插入本地消息</a><br>网易云信iOS本地消息插入 |保存消息到本地数据库，但不发送到服务器端，仅仅支持文本消息、提醒消息、自定义消息 | <a href="http://dev.netease.im/docs/product/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/SDK%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90/iOS%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90/%E6%9C%80%E8%BF%91%E4%BC%9A%E8%AF%9D" target="_blank" rel="external">写入本地消息</a></li>
</ol>
<h3 id="聊天交互相关的页面"><a href="#聊天交互相关的页面" class="headerlink" title="聊天交互相关的页面"></a>聊天交互相关的页面</h3><table>
<thead>
<tr>
<th>页面</th>
<th>相关操作 </th>
</tr>
</thead>
<tbody>
<tr>
<td> Application</td>
<td>IM SDK初始化「全局消息通知方式初始化等」 </td>
</tr>
<tr>
<td>注册登录页面</td>
<td>登录app Server完成后进行环信登录，登录完成后加载本地会话和群组到内存中</td>
<td></td>
</tr>
<tr>
<td>闪屏页面</td>
<td>登录完成后加载本地会话和群组到内存中 </td>
</tr>
<tr>
<td>主页面</td>
<td>监听环信连接相关Listener（断开，连接，被踢）<br> 监听群组Listener()<br> 监听环信消息Listener(监听新消息)</td>
</tr>
<tr>
<td>消息会话页面</td>
<td>读取会话列表并展现 </td>
</tr>
<tr>
<td>聊天页面</td>
<td>读取本地记录，接收消息，发送消息 </td>
</tr>
<tr>
<td>设置页面</td>
<td>退出时断开环信连接 </td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android设置透明状态栏相关]]></title>
      <url>https://tomsbee8.github.io/2018/02/03/Android%E4%B8%AD%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>StatusBar和NavigationBar适配详解</p>
<hr>
<h4 id="1-设置全屏"><a href="#1-设置全屏" class="headerlink" title="1.设置全屏"></a>1.设置全屏</h4><p>官方详细介绍：<a href="https://developer.android.com/design/patterns/fullscreen.html#immersive" target="_blank" rel="external">Immersive</a><br>官方示例：<a href="https://github.com/googlesamples/android-AdvancedImmersiveMode" target="_blank" rel="external">sample</a><br>    <a id="more"></a></p>
<h6 id="SystemUIFlag详解"><a href="#SystemUIFlag详解" class="headerlink" title="SystemUIFlag详解"></a>SystemUIFlag详解</h6><table>
<thead>
<tr>
<th>Flag</th>
<th>含义</th>
<th>详细解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>SYSTEM_UI_FLAG_LOW_PROFILE</td>
<td>低能显示状态</td>
<td>状态栏显示处于低能显示状态(low profile模式)，状态栏上一些图标显示会被隐藏。</td>
</tr>
<tr>
<td>SYSTEM_UI_FLAG_FULLSCREEN</td>
<td>Layout全屏显示，且状态栏会被隐藏覆盖</td>
<td>等同于WindowManager.LayoutParame的FLAG_FULLSCREEN，大多时候我们会在splash闪屏页使用</td>
</tr>
<tr>
<td>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</td>
<td>Layout全屏显示，但是状态栏会被覆盖但是不会隐藏</td>
<td>大多时候我们会同时设置状态栏透明</td>
</tr>
<tr>
<td>SYSTEM_UI_FLAG_HIDE_NAVIGATION</td>
<td>隐藏虚拟导航栏</td>
<td></td>
</tr>
<tr>
<td>SYSTEM_UI_FLAG_IMMERSIVE</td>
<td>沉浸模式</td>
<td></td>
</tr>
<tr>
<td>SYSTEM_UI_FLAG_IMMERSIVE_STICKY</td>
<td>Sticky的沉浸模式</td>
<td></td>
</tr>
<tr>
<td>SYSTEM_UI_FLAG_LAYOUT_STABLE</td>
<td>提高UI稳定</td>
<td>保持Layout不变，隐藏状态栏或者导航栏后，View不会拉伸。</td>
</tr>
</tbody>
</table>
<h6 id="全屏模式细分："><a href="#全屏模式细分：" class="headerlink" title="全屏模式细分："></a>全屏模式细分：</h6><table>
<thead>
<tr>
<th>模式</th>
<th>包含的Flag</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>leanbackMode</td>
<td>SYSTEM_UI_FLAG_FULLSCREEN、SYSTEM_UI_FLAG_HIDE_NAVIGATION</td>
<td>点击屏幕任意地方都会退出全屏模式</td>
</tr>
<tr>
<td>ImmersiveMode</td>
<td>SYSTEM_UI_FLAG_FULLSCREEN、SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN、SYSTEM_UI_FLAG_HIDE_NAVIGATION、SYSTEM_UI_FLAG_IMMERSIVE</td>
<td>点击屏幕不会退出全屏，从状态栏或者导航栏滑动到内容区域会退出全屏模式，会清除flag,并触发View.OnSystemUiVisibilityChangeListener()事件监听</td>
</tr>
<tr>
<td>ImmersiveStickyMode</td>
<td>SYSTEM_UI_FLAG_FULLSCREEN、SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN、SYSTEM_UI_FLAG_HIDE_NAVIGATION、SYSTEM_UI_FLAG_IMMERSIVE_STICKY</td>
<td>点击屏幕不会退出全屏，从状态栏或者导航栏滑动到内容区域会暂时退出全屏模式（过一会儿如果没有操作又回进入全屏模式），并且状态栏和导航栏处于半透明的状态,不会清除flag,不会触发View.OnSystemUiVisibilityChangeListener()事件监听</td>
</tr>
</tbody>
</table>
<p>#### </p>
<ol>
<li>设置透明状态栏<br>Android 系统从4.4开始支持透明状态栏,效果在 4.4.x 和 5.x 上表现不同，4.4.x 是一层渐变的遮罩层；5.x 以上是一条半透明的遮罩层。</li>
</ol>
<ul>
<li>通过theme 设置：</li>
</ul>
<p>values-19文件夹中的style：</p>
<pre><code>&lt;style name=&quot;AppTheme.ExtendStatusBar&quot; parent=&quot;AppTheme&quot;&gt;
     &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre><ul>
<li>通过代码设置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</div></pre></td></tr></table></figure>
<p>设置完毕后，还需要给layout 设置fitsSystemWindows属性为true，系统就会调整该view的padding值来留出空间给系统窗体。表现为，padding出status bar的高度给status bar使用，不至于我们定义layout跟status bar重叠！<br>这是因为fitsSystemWindows属性使得布局的paddingTop被重新改写了（paddingTop增加了状态栏的高度）。也可以通过代码来设置，需要在setContentView()方法 之后添加(代码来自<a href="https://www.jianshu.com/p/0acc12c29c1b" target="_blank" rel="external">这里</a>)</p>
<pre><code>ViewGroup contentFrameLayout = (ViewGroup) findViewById(Window.ID_ANDROID_CONTENT);
    View parentView = contentFrameLayout.getChildAt(0);
    if (parentView != null &amp;&amp; Build.VERSION.SDK_INT &gt;= 14) {
        parentView.setFitsSystemWindows(true);
    }
</code></pre><h4 id="3-设置状态栏背景颜色"><a href="#3-设置状态栏背景颜色" class="headerlink" title="3. 设置状态栏背景颜色"></a>3. 设置状态栏背景颜色</h4><p>Android 系统从5.0开始支持设置状态栏的背景颜色</p>
<ul>
<li>通过theme 设置：</li>
</ul>
<p>values-21文件夹中的style：</p>
<pre><code>&lt;style name=&quot;AppTheme.Main&quot; parent=&quot;AppTheme&quot;&gt;
    &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/holo_red_dark&lt;/item&gt;
&lt;/style&gt;
</code></pre><ul>
<li><p>通过代码设置：</p>
<pre><code>activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
  activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  activity.getWindow().setStatusBarColor(calculateStatusColor(color, statusBarAlpha));
</code></pre></li>
</ul>
<h4 id="4-设置状态栏字体颜色"><a href="#4-设置状态栏字体颜色" class="headerlink" title="4. 设置状态栏字体颜色"></a>4. 设置状态栏字体颜色</h4><p>Android 6.0API window添加了一个<a href="https://developer.android.com/reference/android/R.attr.html#windowLightStatusBar" target="_blank" rel="external">windowLightStatusBar</a>的属性，是为了解决当状态栏被设为和白色相近的浅色的话，状态栏上的系统图标文字就看不到了的问题。</p>
<ul>
<li>通过theme 设置：</li>
</ul>
<p>values-23文件夹中的style：</p>
<pre><code>&lt;style name=&quot;AppTheme.Main&quot; parent=&quot;AppTheme&quot;&gt;
    &lt;item name=&quot;android:windowLightStatusBar&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre><ul>
<li><p>通过代码设置：</p>
<pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
    int uiOptions = activity.getWindow().getDecorView().getSystemUiVisibility();
    uiOptions |=View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
}
</code></pre></li>
</ul>
<p>魅族Flyme和小米MIUI本身提供了修改状态栏的文字和图标颜色的方法，可以将状态栏的系统文字和图标颜色设置为深色。<br>魅族手机状态栏设置：<a href="http://open-wiki.flyme.cn/index.php?title=%E7%8A%B6%E6%80%81%E6%A0%8F%E5%8F%98%E8%89%B2" target="_blank" rel="external">官方文档</a><br>小米手机状态栏设置：<a href="https://dev.mi.com/console/doc/detail?pId=1159" target="_blank" rel="external">官方文档</a></p>
<p>以上两个官方文档中都有设置代码，我汇总一下，最终代码如下：</p>
<pre><code>/**
 * 设置动态变色的状态栏
 *
 * @param activity     当前activity
 * @param isLightColor 是否是淡色
 */
public static void setLightStatusBar(@NonNull Activity activity, boolean isLightColor) {
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
        if (isLightColor) {
            int uiOptions = activity.getWindow().getDecorView().getSystemUiVisibility();
            uiOptions |= View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
            activity.getWindow().getDecorView().setSystemUiVisibility(uiOptions);
        } else {
            int uiOptions = activity.getWindow().getDecorView().getSystemUiVisibility();
            uiOptions &amp;= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
            activity.getWindow().getDecorView().setSystemUiVisibility(uiOptions);
        }
    } else {
        if (RomUtil.isMIUI()) {
            setMIUIStatusBarDarkMode(activity, isLightColor);
        } else if (RomUtil.isFlyme()) {
            setFlymeStatusBarDarkMode(activity, isLightColor);
        }
    }
}

/**
 * 在旧的MIUI版本(Android 6.0以下)设置状态栏字体颜色
 *
 * @param activity 当前activity
 * @param darkmode 是否为黑色字体图标
 */
private static void setMIUIStatusBarDarkMode(@NonNull Activity activity, boolean darkmode) {
    Class&lt;? extends Window&gt; clazz = activity.getWindow().getClass();
    try {
        int darkModeFlag = 0;
        Class&lt;?&gt; layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;);
        Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;);
        darkModeFlag = field.getInt(layoutParams);
        Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class);
        extraFlagField.invoke(activity.getWindow(), darkmode ? darkModeFlag : 0, darkModeFlag);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

/**
 * 在旧的Flyme版本(Android 6.0以下)设置状态栏字体颜色
 *
 * @param activity 当前activity
 * @param darkmode 是否为深色字体图标
 */
private static void setFlymeStatusBarDarkMode(@NonNull Activity activity, boolean darkmode) {

    try {
        ViewGroup.LayoutParams winParams = activity.getWindow().getAttributes();
        Field f = winParams.getClass().getDeclaredField(&quot;MEIZU_FLAG_DARK_STATUS_BAR_ICON&quot;);
        f.setAccessible(true);
        int bits = f.getInt(winParams);
        Field f2 = winParams.getClass().getDeclaredField(&quot;meizuFlags&quot;);
        f2.setAccessible(true);
        int meizuFlags = f2.getInt(winParams);
        int oldFlags = meizuFlags;
        if (darkmode) {
            meizuFlags |= bits;
        } else {
            meizuFlags &amp;= ~bits;
        }
        if (oldFlags != meizuFlags) {
            f2.setInt(winParams, meizuFlags);
        }
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (IllegalArgumentException e) {
        e.printStackTrace();
    } catch (Throwable e) {
        e.printStackTrace();
    }
}
</code></pre><h5 id="已知的手机适配问题"><a href="#已知的手机适配问题" class="headerlink" title="已知的手机适配问题"></a>已知的手机适配问题</h5><ul>
<li>华为EMUI3.1（Android5.0／5.1 Lollipop） 状态栏设置无效。经过验证，无法按照5.0 API 设置，但是可以按照4.4 API设置，设置后的效果也r仍然是4.4API的效果。</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul>
<li><a href="http://blog.csdn.net/mafei852213034/article/details/51769952" target="_blank" rel="external">http://blog.csdn.net/mafei852213034/article/details/51769952</a></li>
<li><a href="http://blog.csdn.net/mafei852213034/article/details/51769952" target="_blank" rel="external">http://blog.csdn.net/mafei852213034/article/details/51769952</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈BaseActivity的封装]]></title>
      <url>https://tomsbee8.github.io/2017/03/14/%E5%85%B3%E4%BA%8EBaseActivty%E5%92%8CBaseFragment%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<h2 id="浅谈BaseActivity的封装"><a href="#浅谈BaseActivity的封装" class="headerlink" title="浅谈BaseActivity的封装"></a>浅谈BaseActivity的封装</h2><p>在项目中，我们在使用Activity和fragment的时候一般会在基类里封装一些共有的逻辑，每个人可能都有不同封装思路，考虑的逻辑也会不同。这些共有的逻辑有很多,下面就来总结下我们通常会考虑的一些封装内容。</p>
<ol>
<li><strong>状态栏，底部导航栏设置</strong><br>系统从4.4开始支持透明状态栏,效果在不同版本上表现不同，实现方式主要有设置主题style 和在activity中手动设置需要对每个Activity进行适配。现在的App大多都对状态栏进行适配。这些都是一些相同的逻辑：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setStatusBar();</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"> protected void setStatusBar() &#123;</div><div class="line">   SystemBarUtil.setTranslucentStatusBar(this,true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中SystemBarUtil的封装参见我的 SystemBarUtil</p>
<ol>
<li><strong>共有的控件，如toolbar或者自定义的titleBar</strong> <a id="more"></a>
Toolbar作为谷歌推荐的标题栏控件,其使用很普遍，当然也有人喜欢自定义布局作为标题栏（此处不另外写例子）。如<br>果在每个Activity里面都写一个Toolbar的话，显然有点冗余，一般情况下在BaseActivity封装好Toolbar，在子类用BaseActivity提供的方法调用即可。<br>先是基类的layout文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;android.support.constraint.ConstraintLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;android.support.v7.widget.Toolbar</div><div class="line">        android:id=&quot;@+id/common_tb&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;56dp&quot;</div><div class="line">        android:background=&quot;@color/main_color&quot;</div><div class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot;</div><div class="line">        app:layout_collapseMode=&quot;pin&quot;</div><div class="line">        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/common_center_tv&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:layout_gravity=&quot;center&quot;</div><div class="line">            android:singleLine=&quot;true&quot;</div><div class="line">            android:textSize=&quot;15sp&quot;</div><div class="line">            android:text=&quot;标题&quot;</div><div class="line">            android:textColor=&quot;@android:color/white&quot; /&gt;</div><div class="line">    &lt;/android.support.v7.widget.Toolbar&gt;</div><div class="line"></div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:id=&quot;@+id/common_content_rl&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;0dp&quot;</div><div class="line">        app:layout_constraintTop_toBottomOf=&quot;@+id/common_tb&quot;</div><div class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;/RelativeLayout&gt;</div><div class="line"></div><div class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</div></pre></td></tr></table></figure>
<p>然后是基类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private Toolbar mToolbar;</div><div class="line">    private RelativeLayout mContentRL;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(getContentLayout());</div><div class="line">        setToolBar();</div><div class="line">        initView();</div><div class="line">        initData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onNewIntent(Intent intent) &#123;</div><div class="line">        super.onNewIntent(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract @LayoutRes int getLayout();</div><div class="line"></div><div class="line">    protected @LayoutRes int getContentLayout()&#123;</div><div class="line">        if(useToolbar())&#123;</div><div class="line">            return R.layout.common_toolbar_container;</div><div class="line">        &#125;else&#123;</div><div class="line">            return getLayout();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract boolean useToolbar();</div><div class="line"></div><div class="line">    protected abstract void initView();</div><div class="line"></div><div class="line">    protected abstract void initData();</div><div class="line"></div><div class="line">    protected void setToolBar()&#123;</div><div class="line">        mToolbar = (Toolbar) findViewById(R.id.common_tb);</div><div class="line">        setSupportActionBar(mToolbar);</div><div class="line">        android.support.v7.app.ActionBar actionBar = getSupportActionBar();</div><div class="line">        if (actionBar != null)&#123;</div><div class="line">            actionBar.setDisplayHomeAsUpEnabled(true);</div><div class="line">            actionBar.setDisplayShowTitleEnabled(false);</div><div class="line">        &#125;</div><div class="line">        mContentRL = (RelativeLayout) findViewById(R.id.common_content_rl);</div><div class="line">        if(useToolbar())&#123;</div><div class="line">            LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">            View contentView = inflater.inflate(getLayout(), null);</div><div class="line">            ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</div><div class="line">                    ViewGroup.LayoutParams.MATCH_PARENT);</div><div class="line">            mContentRL.addView(contentView, params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>基本生命周期以及第三方统计</strong></li>
</ol>
<p>用过友盟数据统计的同学应该知道，为了统计每个页面的点击事件，页面访问路径，异常信息等我们需要在Activity的生命周期方法中添加友盟的API，这些都是一些相同的逻辑，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onResume() &#123;</div><div class="line">    MobclickAgent.onResume(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onPause() &#123;</div><div class="line">    MobclickAgent.onPause(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>进出场动画效果</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    overridePendingTransition(R.anim.fade_in, R.anim.fade_out);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void finish() &#123;</div><div class="line">    super.finish();</div><div class="line">    overridePendingTransition(R.anim.fade_in, R.anim.fade_out);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>定义一些共有的UI操作，例如toast,popupWindow,snackbar,dialog</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void showLoadingPregoress() &#123;</div><div class="line">     ...</div><div class="line">&#125;</div><div class="line">public void showLoadingDialog() &#123;</div><div class="line">     ...</div><div class="line">&#125;</div><div class="line">public void showLoadingDialog(String msg) &#123;</div><div class="line">     ToastUtil.showSingleShortToast(this,msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>登陆Token过期处理</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void showTokenInvalid(String code,String msg) &#123;</div><div class="line">      ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>不同页面状态下的显示处理</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void showLoadingView() &#123;</div><div class="line">     ...</div><div class="line">&#125;</div><div class="line">public void showGetDataError(String code,String msg) &#123;</div><div class="line">     ...</div><div class="line">&#125;</div><div class="line">public void showGetDataEmpty() &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>网络变化监听</strong></li>
</ol>
<p>由于几乎大部分页面Activity都会有网络请求，会对网络断开或者连接的时候，而且页面对数据及时性有要求的话，及时将网络变化告知给用户也很有必要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</div><div class="line">registerReceiver(new BroadcastReceiver() &#123;</div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        if (!NetUtils.isConnnected(context)) &#123;</div><div class="line">            ...</div><div class="line">        &#125; else &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, filter);</div></pre></td></tr></table></figure>
<ol>
<li><strong>运行时的权限处理</strong></li>
</ol>
<p>如果我们将app的target Version 设置为26 及以上，我们在使用一些危险的权限时候，需要对运行时的权限进行处理。<br>如果我们自己多对，当然我们可以也选择其他的运行时的权限处理库（例如<a href="https://github.com/googlesamples/easypermissions" target="_blank" rel="external">easypermissions</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    checkAllNeedPermissions(getNeedPermissions());</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 获取需要进行检测的权限数组</div><div class="line"> */</div><div class="line">protected void  checkAllNeedPermissions(String [] permissions);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 获取需要进行检测的权限数组</div><div class="line"> */</div><div class="line">protected abstract String[] getNeedPermissions();</div><div class="line"></div><div class="line">/**</div><div class="line"> * 权限授权成功回调</div><div class="line"> */</div><div class="line">protected abstract void permissionGrantedSuccess();</div><div class="line"></div><div class="line">/**</div><div class="line"> * 权限授权失败回调</div><div class="line"> */</div><div class="line">protected abstract void permissionGrantedFail();</div></pre></td></tr></table></figure>
<ol>
<li><strong>一些常用的第三方库在使用中，亦可以进行自己的轻微封装操作</strong>，诸如</li>
</ol>
<ul>
<li>使用Butterknife的处理</li>
</ul>
<p>使用Butterknife的时候，是有注册也必须要有反注册的机制，虽然可以右键一键生成，但是代码还是有可以复用的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(getLayout());</div><div class="line">    mUnBinder = ButterKnife.bind(this);</div><div class="line">     ...</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">protected void onDestroy() &#123;</div><div class="line">    super.onDestroy();</div><div class="line">    mUnBinder.unbind();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>使用EveentBus的处理</p>
<p>  使用EventBus的时候，是有注册也必须要有反注册的机制，因为Activity不是常驻内存的，Activity也有销毁的时候，这时候就需要从EventBus中“反注册”，可以在基类Activity声明周期方法中完成：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    ...</div><div class="line">    EventBus.getDefault().register(this);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDestroy() &#123;</div><div class="line">    super.onDestroy();</div><div class="line">    ...</div><div class="line">    EventBus.getDefault().unregister(this);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void onEventMainThread(BaseEvent event) &#123;</div><div class="line">    ...doSomething...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>虽然时间总线的使用可以松耦合，当由于过多使用事件总线的时候，代码将变的混乱不堪，阅读性变得很差 ，所以不是特别推荐在基类中做EventBus的处理，可以按需使用。</p>
<ul>
<li>MVP模式下的BaseActivity</li>
</ul>
</blockquote>
<pre><code>基类activity 充当V层 ，会引用到Presenter,我们需要根据activity 来控制Presenter在内存中的情况，避免内存泄露。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(getLayout());</div><div class="line">  </div><div class="line">    initInject();</div><div class="line">    if (mPresenter != null) &#123;</div><div class="line">        mPresenter.attachView(this);</div><div class="line">    &#125;</div><div class="line">    initView();</div><div class="line">    initData(savedInstanceState);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDestroy() &#123;</div><div class="line">    super.onDestroy();</div><div class="line">    if (mPresenter != null) &#123;</div><div class="line">        mPresenter.detachView();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>加入Dagger 2 后的BaseActivity</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected ActivityComponent getActivityComponent()&#123;</div><div class="line">        return  DaggerActivityComponent.builder()</div><div class="line">                .appComponent(App.getAppComponent())</div><div class="line">                .activityModule(new ActivityModule(this))</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 初始化依赖注入</div><div class="line">    protected abstract void initInject();</div></pre></td></tr></table></figure>
<p>鉴于每个人的编码风格习惯和具体APP的需求都是不同的，,一般我们不会把上面的逻辑全都加到基类中去，如果BaseActivity里的逻辑太多，会显得太重，代码也会产生功能冗余。上面总结的那些共有逻辑，也可以按需加入到BaseActivity中去</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Arc 代码审查规范流程]]></title>
      <url>https://tomsbee8.github.io/2017/01/03/Arc%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E8%A7%84%E8%8C%83%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h5 id="Arc-代码审查规范流程"><a href="#Arc-代码审查规范流程" class="headerlink" title="Arc 代码审查规范流程"></a>Arc 代码审查规范流程</h5><p>我们认为CodeReview代码审查的直接作用就是规范代码习惯、找出潜在缺陷、BUG，优化代码设计，对产品质量进行把关。对于码农来说也是有好处的，可以促进工程师日常代码交流和帮助个人的成长。</p>
<p>最近公司选用Phabricator作为内部的的代码评审工具。配合Arcanist使用感觉还是挺不错的。其中Arcanist作为提交代码评审的工具。</p>
<h5 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h5><ol>
<li>从主干上面切换到此开发分支：git checkout   develop</li>
<li>提交信息git commit -m “xxxMessage”</li>
<li>提交与远端develop分支的差异revision：arc diff origin/develop  <a id="more"></a> 
</li>
</ol>
<blockquote>
<p>Attention: 如果当前分支已经有未推送的revision,将会update revision,而不会产生新的revision，如果需要另加revision，可以使用：arc diff –create origin/develop</p>
</blockquote>
<ol>
<li>推送到远端develop分支：arc land –onto develop </li>
</ol>
<blockquote>
<p>Attention: 如果不指定分支，直接使用arc land ,将会自动合并到 origin master 并且删除当前本地develop分支，当然也可通过配置设置arc.land.onto.default来指定默认推送分支：arc set-config  arc.land.onto.default develop </p>
</blockquote>
<h5 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h5><ul>
<li><p>配置arc的默认编辑器使用vi，可以直接命令行执行：</p>
<p>  arc set-config editor “vim”<br>或者修改当前用户目录下的.arcrc文件：</p>
</li>
</ul>
<pre><code>{
  &quot;hosts&quot;: {
    &quot;xxxx&quot;: {
      &quot;token&quot;: &quot;xxxxx&quot;
    }
  },
 &quot;config&quot;: {
    &quot;editor&quot;: &quot;vim&quot;,
    &quot;arc.land.onto.default&quot;: &quot;develop&quot;
  }
} 
</code></pre><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><ul>
<li><a href="https://secure.phabricator.com/book/phabricator/article/arcanist/" target="_blank" rel="external">Arcanist User Guide</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[App启动页性能优化]]></title>
      <url>https://tomsbee8.github.io/2016/10/03/App%E5%90%AF%E5%8A%A8%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>我在最初接触开发Android的时候，一直对启动页没有太多关注，大多数时候我们接触的App的启动页都是，一张图片（或多或少的会多一些其他的组件，比如“倒计时”，“跳过”啥的），启动页一般都会放置一个占位符，它存在的目的就是为了让用户在等待的过程中忽略这个开启的过程，其实也就是大家所说的提高了用户体验度，降低用户焦虑感。</p>
<p>app的启动方式：  </p>
<ol>
<li>冷启动<br>当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。冷启动因为系统会重新创建一个新的进程分配给它，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。<br>app的冷启动流程：<br>Application的构造器方法—&gt;attachBaseContext()—&gt;onCreate()—&gt;Activity的构造方法—&gt;onCreate()—&gt;配置主题中背景等属性—&gt;onStart()—&gt;onResume()—&gt;测量布局绘制显示在界面上  </li>
<li>热启动<br>当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会   <a id="more"></a> 
保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。热启动因为会从已有的进程中来启动，所以热启动就不会走Application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化Application，因为一个应用从新进程的创建到进程的销毁，Application只会初始化一次。  </li>
<li>温启动<br>介于冷启动和热启动之间, 一般来说在以下两种情况下发生：1.用户back退出了App, 然后又启动. App进程可能还在运行, 但是activity需要重建;2.用户退出App后, 系统可能由于内存原因将App杀死, 进程和activity都需要重启, 但是可以在onCreate中将被动杀死锁保存的状态(saved instance state)恢复。</li>
</ol>
<p><strong>从冷启动的流程上看，启动性能的优化主要优化Application和启动页activity(或叫闪屏页)两个方面。</strong></p>
<ol>
<li><p>启动页的时间怎么消耗<br><strong>消耗时间主要会用在application的初始化和闪屏activity的生命周期。</strong></p>
<ul>
<li>大多时候，我们app 的application初始化的时候做的工作有，配置网络请求、第三方SDK的初始化、。这些操作都是很消耗时间的。  我们可以单独拎出来，放到一个线程里处理，比如IntentService 就很好。  </li>
<li><p>在闪屏activity的生命周期中我们会一些加载用户数据等，者也是需要消耗时间的。一般情况下，都是设计的延迟时间（大多是2S~5S）从启动页跳转到主页面，例如：</p>
<pre><code>new Handler().postDelayed(new Runnable() {
     @Override
       public void run() {
         startActivity(new Intent(StartActivity.this,MainActivity.class));
       }
}, 3000);
</code></pre></li>
</ul>
<ul>
<li>如果我们做了耗时操作，往往时间会超过3S,我们可以使用计时器，把这些操作包含在那2~5s内。</li>
</ul>
</li>
<li><p>启动页的背景画面设计<br> <strong>有两种情况</strong>：</p>
<ul>
<li><p>启动页activity不渲染布局，即没有setContentView()方法。但是给该activity的theme中设置background成图片（可以是logo）。<br>给我们的应用窗口弄一个<a href="https://material.google.com/patterns/launch-screens.html#launch-screens-branded-launch" target="_blank" rel="external">PlaceHolder</a>  ：   </p>
<pre><code>&lt;style name=&quot;SplashTheme&quot; parent=&quot;AppTheme&quot;&gt;
     &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;
     &lt;item name=&quot;Android:windowBackground&quot;&gt;@drawable/splash_background&lt;/item&gt;
&lt;/style&gt;
</code></pre></li>
<li><p>启动页activity渲染布局，即有自己的渲染布局，有一些自己的组件，比如“图片广告”，“跳过”，“倒计时”，甚至是视频广告。<br>需要注意的是布局不能太复杂,因为渲染需要花费时间。<br>当App没有完全起来时, 进入该activity的时候屏幕会一直显示一块空白的窗口(一般来说是黑屏或者白屏).这样的话，体验将非常不好(虽然很快，就一闪而过),这个空白的窗口展示跟主题相关, 我们需要设置该activity的windowBackground的主题属性, 我们一般是单独为该activity设置为透明主题，即：  </p>
<pre><code>&lt;style name=&quot;SplashTheme&quot; parent=&quot;AppTheme&quot;&gt;
     &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;
     &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>当然，也有更好的方法，关闭android:windowDisablePreview即可，没必要设置透明，增大开销：  </p>
<pre><code>&lt;style name=&quot;SplashTheme&quot; parent=&quot;AppTheme&quot;&gt;
     &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;
     &lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre></li>
</ul>
</li>
<li><p>启动页的特效<br>这个启动页界面往往实现了渐变，loading等效果，这样启动页面的耗时比较长的话，用户也不会觉得时间很长，难以忍受，当然了这种方式只是在视觉效果上造成“启动页面加载速度很快”的效果的。</p>
</li>
<li><p>返回键功能设计<br>返回键大多数时候会被屏蔽：</p>
<pre><code> @Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
if (keyCode == KeyEvent.KEYCODE_BACK) {
    return true;
}
return super.onKeyDown(keyCode, event);
}
</code></pre></li>
</ol>
<h5 id="其他需要注意的地方-："><a href="#其他需要注意的地方-：" class="headerlink" title="其他需要注意的地方 ："></a>其他需要注意的地方 ：</h5><ul>
<li>不要在application里面直接缓存数据，不要放置太多static final 的数据。因为Application会因为进入background后内存不足被系统干掉，进入后系统会重现创建一个Application类，而导致缓存在Application类里的数据全部初始化而丢失。</li>
<li>不需要再单例application,因为application本来就是针对一个进程里所有组件唯一的。需要引用的话，直接getApplication().</li>
<li>尽量不要在在Application中做关于文件，数据库，sharedPreference的操作，可以考虑单独线程了做这些工作</li>
</ul>
<p>本文参考了 ：<br><a href="http://blog.csdn.net/yanzhenjie1003/article/details/52201896" title="秒开" target="_blank" rel="external">http://blog.csdn.net/yanzhenjie1003/article/details/52201896</a><br><a href="http://www.jianshu.com/p/4f10c9a10ac9" target="_blank" rel="external">http://www.jianshu.com/p/4f10c9a10ac9</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android性能优化(电量优化)]]></title>
      <url>https://tomsbee8.github.io/2016/09/25/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96)/</url>
      <content type="html"><![CDATA[<h4 id="二-电量优化"><a href="#二-电量优化" class="headerlink" title="二.电量优化"></a>二.电量优化</h4><p>手机各个硬件模块的耗电量是不一样的，有些模块非常耗电，而有些模块则相对显得耗电量小很多。</p>
<p>android应用的耗电主要在以下三个方面：</p>
<ol>
<li>大数据量的传输。</li>
<li>不停的在网络间切换。</li>
<li>解析大量的文本数据。</li>
</ol>
<p>优化建议：</p>
<ol>
<li>在需要网络连接的程序中，首先检查网络连接是否正常，如果没有网络连接，那么就不需要执行相应的程序。</li>
<li>应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据。</li>
<li>在移动网络下，最好做到批量执行网络请求，尽量避免频繁的间隔网络请求。  <a id="more"></a></li>
<li>使用效率高的数据格式和解析方法，推荐使用JSON和Protobuf</li>
<li>目在进行大数据量下载时，尽量使用GZIP方式下载</li>
<li>对定位要求不是太高的话尽量不要使用GPS定位，可能使用wifi和移动网络定位即可</li>
<li>正确申请和释放WakeLock</li>
<li>不要频繁唤醒手机</li>
<li>正确使用Alarm</li>
<li>节制地使用Service</li>
<li>使用Job Scheduler，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起进行执行。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android性能优化(内存优化)]]></title>
      <url>https://tomsbee8.github.io/2016/09/25/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96)/</url>
      <content type="html"><![CDATA[<h4 id="二-内存优化"><a href="#二-内存优化" class="headerlink" title="二.内存优化"></a>二.内存优化</h4><p>内存是Android设备中非常宝贵的资源，通常被认为比CPU宝贵的多，Android是多进程后台多任务的，当后台有太多进程的时候，内存的优化显得很重要。</p>
<p>Android系统级内存管理机制其实类似于Java的垃圾回收机制，Linux在进程停止后就结束该进程，而Android把这些停止的进程都保留在内存中，直到系统需要更多内存时才选择性的释放一些，保留在内存中的进程默认（不包含后台service与Thread等单独UI线程的进程）不会影响整体系统的性能（速度与电量等）且当再次启动这些保留在内存的进程时可以明显提高启动速度，不需要再去加载。在Android系统中框架会给进程设置优先级，而且优先级会随着内存使用情况和用户的操作和不断变化，在系统内存达到规定的不同阀值时消灭不同优先级的进程。</p>
<p><strong>Android的GC机制</strong>：</p>
<ol>
<li>Android里面有一个三级Generation的内存模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。 <a id="more"></a></li>
<li>执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。</li>
<li>Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</li>
</ol>
<p><strong>内存泄露</strong>：内存泄漏是指分配出去的内存无法回收了</p>
<p><strong>内存溢出</strong>：程序要求的内存，超出了系统所能分配的范围，从而发生溢出</p>
<p><strong>通过工具定位分析问题：</strong></p>
<ol>
<li>Memory Monitor：查看整个app所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号。</li>
<li>Allocation Tracker：使用此工具来追踪内存的分配，追踪内存对象的来源。</li>
<li>Heap Viewer：查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的。</li>
<li>接入<a href="https://github.com/square/leakcanary" target="_blank" rel="external">LeakCanary</a>分析内存泄露</li>
<li>使用Lint选项检查可能的代码隐患</li>
</ol>
<p><strong>通过代码进行优化</strong></p>
<ul>
<li>Service的方法是在UI线程执行的，考虑使用 IntentService，AsyncTask，Executors，Handler 和 Loopers(Looper.myLooper() == Looper.getMainLooper() 是可以帮助你确定你是否在主线程的代码)。</li>
<li>对大图片，先获取图片的大小信息，根据实际需要展示大小计算inSampleSize，最后decode；</li>
<li>在合适的条件下使用SparseArray替换HashMap</li>
<li>在拼接字符串的时候，使用StringBuilder或者StringBuffer代替String</li>
<li>对于I/O需要频繁操作的，主要是和外部存储相关的I/O操作，MemoryFile通过将 NAND或SD卡上的文件，分段映射到内存中进行修改处理，这样就用高速的RAM代替了ROM或SD卡，性能自然提高不少</li>
<li>android.text.format包下的Formatter类，提供了IP地址转换、文件大小转换等方法；DateFormat类，提供了各种时间转换，都是非常高效的方法。</li>
<li>使用 System.arraycopy()代替 for 循环复制。</li>
<li>利用系统自带的资源（如string，style，color）</li>
<li>View中设置缓存属性.setDrawingCache为true</li>
<li>虽然枚举类型的可读性较好，避免使用枚举，使用注解和static final代替，例如：</li>
</ul>
<pre><code>public class Colors {
        @IntDef({RED, GREEN, YELLOW})
        @Retention(RetentionPolicy.SOURCE)
        public @interface LightColors{}

        public static final int RED = 0;
        public static final int GREEN = 1;
        public static final int YELLOW = 2;
    }
</code></pre><ul>
<li>大量使用反射会影响性能，适当少的使用反射原理的第三方库 。</li>
<li>在慎用异常,异常对性能不利，抛出异常首先要创建一个新的对象。Throwable 接口的构造函数用名为fillInStackTrace() 的本地方法,fillInStackTrace() 方法检查栈,收集调用跟踪信息。只要有异常被抛出,VM 就必要调整调用栈,因为在处理过程中创建了一个新对象。</li>
<li>使用高性能的第三方图片缓存库，如Glide,Picasco等</li>
<li>尽量使用线程池替代多线程操作，这样可以节约内存及CPU占用率。</li>
<li>需要使用ContentProvider对多行数据进行更新、插入、删除数据操作的时候，使用ContentProviderOperation工具类进行批量操作，</li>
<li>使用ProGuard来剔除不需要的代码 ，减少冗余，避免类加载时浪费内存。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android性能优化(视图优化)]]></title>
      <url>https://tomsbee8.github.io/2016/09/25/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E8%A7%86%E5%9B%BE%E4%BC%98%E5%8C%96)/</url>
      <content type="html"><![CDATA[<h4 id="一-视图优化"><a href="#一-视图优化" class="headerlink" title="一.视图优化"></a>一.视图优化</h4><p>大多数手机的屏幕刷新频率是60hz，如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。</p>
<p>渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。</p>
<p>有很多原 因可以导致丢帧卡顿：</p>
<ol>
<li>人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</li>
<li>布局Layout过于复杂，无法在16ms内完成渲染；</li>
<li>同一时间动画执行的次数过多，导致CPU或GPU负载过重； <a id="more"></a></li>
<li>View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；</li>
<li>View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；</li>
<li>内存频繁触发GC过多（内存抖动），导致暂时阻塞渲染操作；</li>
<li>冗余资源及逻辑等导致加载和执行缓慢；</li>
<li>工作线程优先级未设置为Process.THREAD_PRIORITY_BACKGROUND,导致后台线程抢占UI线程cpu时间片，阻塞渲染操作；</li>
</ol>
<p><strong>过度绘制</strong>：描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。这样就会浪费大量的CPU以及GPU资源。<br> 避免过度绘制，如果出现了，那么很可能会造成刷新率下降，造成卡顿的现象</p>
<p><strong>通过工具定位分析问题：</strong></p>
<ul>
<li>使用HierarchyViewer来查找Activity中的布局是否过于复杂。</li>
<li>通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，观察UI上的过度绘制情况。</li>
<li>复杂的自定义的View(重写了onDraw方法)，Android系统无法检测具体在onDraw里面会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过canvas.clipRect()来 帮助系统识别那些可见的区域。</li>
</ul>
<p><strong>通过代码进行优化</strong></p>
<ul>
<li>移除XML布局文件中非必需的Background</li>
<li>采用<merge>优化布局层数，尽量减少布局层数。</merge></li>
<li>采用&lt;include＞来共享布局.</li>
<li>使用ViewSub来提高加载性能。延时加载View. 避免一些不经常的视图长期被引用，占用内存. </li>
<li><p>尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，对于层数比较多的布局可以考虑使用约束布局：</p>
<pre><code>compile &apos;com.android.support.constraint:constraint-layout:1.0.0-alpha8&apos;
</code></pre></li>
<li><p>使用merge标签减少布局的嵌套层次</p>
</li>
<li><p>尽量避免使用包含layout_weight属性的线性布局，因为每个子组件都需要被测量两次，会在绘制的时候浪费系统资源。尤其是当作为listview 或者GridView的item的布局的时候，建议使用RelativeLayout,也可以考虑使用<a href="https://developer.android.com/topic/libraries/support-library/features.html#percent" target="_blank" rel="external">百分比布局</a>：</p>
<pre><code>com.android.support:percent:24.2.1
</code></pre></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
